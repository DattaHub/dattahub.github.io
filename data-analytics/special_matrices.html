<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jyotishka Datta">

<title>Special matrices</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="special_matrices_files/libs/clipboard/clipboard.min.js"></script>
<script src="special_matrices_files/libs/quarto-html/quarto.js"></script>
<script src="special_matrices_files/libs/quarto-html/popper.min.js"></script>
<script src="special_matrices_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="special_matrices_files/libs/quarto-html/anchor.min.js"></script>
<link href="special_matrices_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="special_matrices_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="special_matrices_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="special_matrices_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="special_matrices_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Special matrices</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jyotishka Datta </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="three-special-matrices" class="level2">
<h2 class="anchored" data-anchor-id="three-special-matrices">Three special matrices</h2>
<p>We will commonly encounter three special matrices in multivariate statistics class. They are, namely,</p>
<ul>
<li>the dispersion matrix <span class="math inline">\(\mathbf{S}\)</span>, or the variance-covariance matrix.</li>
<li>the correlation matrix <span class="math inline">\(\mathbf{R}\)</span>, and</li>
<li>the distance matrix <span class="math inline">\(\mathbf{D}\)</span>.</li>
</ul>
<p>For this notes, we only consider the sample versions (or the “empirical”) dispersion or correlation matrices but we keep in the back of mind that there are population versions of them. For example, the sample dispersion matrix can be a good estimator of the population dispersion matrix, and so on.</p>
<p>We also denote the data-matrix or what is sometimes called the design matrix as a <span class="math inline">\(n \times p\)</span> matrix. If we have <span class="math inline">\(p\)</span> predictors on <span class="math inline">\(n\)</span> subjects, we can denote the data as a <span class="math inline">\(n \times p\)</span> matrix <span class="math inline">\(\bf{X}\)</span>.</p>
<p><span class="math display">\[
X = \begin{bmatrix} x_{11} &amp; x_{12} &amp; \ldots &amp; x_{1p} \\
x_{21} &amp; x_{22} &amp; \ldots &amp; x_{2p} \\
\ldots &amp; \ldots &amp; \vdots &amp; \ldots \\
x_{n1} &amp; x_{n2} &amp; \ldots &amp;x_{np}
\end{bmatrix} = \begin{pmatrix} \mathbf{x}_1 | \mathbf{x_2} | \cdots | \mathbf{x}_p \end{pmatrix}.
\]</span></p>
<p>The <span class="math inline">\(j^{th}\)</span> column stores the observations for the <span class="math inline">\(j^{th}\)</span> predictor variable and is denoted by <span class="math inline">\(\mathbf{x}_j\)</span> or using matrix notation <span class="math inline">\(x_{.,j}\)</span>. The mean vector or centroid is the vector of length <span class="math inline">\(p\)</span> where each component is the mean of a predictor variable, and it could be written as:</p>
<p><span class="math display">\[ \bar{\bf x} = \begin{pmatrix} \bar{x}_1 \\ \bar{x}_2 \\ \vdots \\ \bar{x}_p \end{pmatrix} \in \mathbb{R}^p\]</span> The three matrices are easily defined by their <span class="math inline">\((i,j)\)</span>-th entries, viz., <span class="math inline">\(s_{ij}, r_{ij}\)</span> and <span class="math inline">\(d_{ij}\)</span>, for the dispersion, correlation and the distance matrix, respectively. If we denote the <span class="math inline">\(i^{th}\)</span> column of <span class="math inline">\(X\)</span></p>
<p>The three special matrices are then defined as follows:</p>
<p><span class="math display">\[\begin{align*}
s_{ij} &amp; = \mathrm{Cov}(x_{.,i}, x_{.,j}) = \frac{1}{n-1}\sum_{k=1}^{n} (x_{ki}-\bar{x}_i)(x_{kj}-\bar{x}_j)\\
r_{ij} &amp;=  \mathrm{Corr}(x_{.,i}, x_{.,j}) = \frac{s_{ij}}{\sqrt{s_{ii} s_{jj}}} \\
d_{ij} &amp; = \mathrm{distance}(x_{i,.}, x_{j,.}).
\end{align*}\]</span></p>
<p>It’s easy to see that the diagonal elements of the dispersion matrix are <span class="math inline">\(s_{ii} = Var(X_i)\)</span>, variance of the <span class="math inline">\(i^{th}\)</span> predictor variable or the <span class="math inline">\(i^{th}\)</span> column. The diagonal elements of the correlation matrix are always 1, correlation of <span class="math inline">\(X_i\)</span> with itself. Similarly, the diagonals of a distance matrix are always <span class="math inline">\(0\)</span>.</p>
<p>It’s also easy to see that if take any non-zero vector <span class="math inline">\(\mathbf{a} = (a_1, \ldots, a_p)\)</span> and consider the linear combination <span class="math inline">\(\mathbf{a}^T \mathbf{x} = a_1 X_1 + \cdots + a_p X_p\)</span>. Then, variance of <span class="math inline">\(\mathbf{a}^T \mathbf{x}\)</span> is given by <span class="math inline">\(\mathbf{a}^T \mathbf{S} \mathbf{a}\)</span>, and since variance is always non-negative (positive if the random variable is not degenerate, i.e.&nbsp;not a fixed constant), we can show that the <span class="math inline">\(S\)</span> matrix is also positive definite (or at least non-negative definite).</p>
<p>Recall that a square matrix <span class="math inline">\(\mathbf{A}\)</span> is said to be positive definite if for every non-zero vector <span class="math inline">\(\mathbf{x}\)</span> we have:</p>
<p><span class="math display">\[
\mathbf{x^T A x} &gt; 0
\]</span></p>
<p>and non-negative definite if <span class="math inline">\(\mathbf{x^T A x} \ge 0\)</span>. We also know that an useful property of positive definite matrices is all of their eigenvalues are real and positive. We also know these two useful properties of eigenvalues:</p>
<p><span class="math display">\[
\begin{gather}
{\rm trace}(A) = \sum_{i} a_{ii} = \sum_{i=1}^{n}{\lambda_i}., \text{ and } {\rm Det}(A) = \lambda_1 \cdots \lambda_n.
\end{gather}
\]</span></p>
<p>This would imply a bunch of easy-to-verify properties:</p>
<ol type="1">
<li><p>Let the eigen-decomposition of the dispersion matrix be: <span class="math inline">\(\mathbf{S = B \Lambda B^T}\)</span>, where <span class="math inline">\(\Lambda\)</span> is a diagonal matrix with eigenvalues <span class="math inline">\(\lambda_1, \ldots, \lambda_p\)</span>, and the <span class="math inline">\(\mathbf{B}\)</span> matrix is made up of eigenvectors in each of the columns. The matrix of eigenvectors is also orthogonal, i.e.&nbsp;<span class="math inline">\(\mathbf{B B^T = I}\)</span> and <span class="math inline">\(\mathbf{B^T B = I}\)</span>, so, we could also write the eigendecomposition as <span class="math inline">\(\mathbf{S = B \Lambda B^{-1}}\)</span>.</p></li>
<li><p>The positive definite-ness of <span class="math inline">\(\mathbf{S}\)</span> would imply that we can order the eigenvalues (and relabel if necessary) so that, we have <span class="math inline">\(\lambda_1 \ge \ldots\ge \lambda_p &gt; 0\)</span>. From the relationships between trace, determinant and the eigenvalues, we can say that for the dispersion matrix, the sum of eigenvalues is equal to its trace, i.e.&nbsp;</p></li>
</ol>
<p><span class="math display">\[
\sum_{i=1}^{p} \lambda_i = \sum_{i=1}^{p} s_{ii} = \sum_{i=1}^{p} \text{Var}(X_i),\quad \text{and} \quad \prod_{i=1}^{p} \lambda_i = \text{Det}(\mathbf{S}) = \text{Generalized variance}.
\]</span> 3. Similarly, one can show that the sum of eigenvalues for the sample correlation matrix is equal to <span class="math inline">\(p\)</span>, the number of variables and the product should be equal to 1.</p>
<section id="r-codes" class="level3">
<h3 class="anchored" data-anchor-id="r-codes">R codes</h3>
<p>We can check these properties easily in <code>R</code>. We look at the environmental dataset in lattice library.</p>
<p>We first look at the eigen-decomposition of the covariance matrix, obtained by <code>cov</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lattice)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(environmental)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>dat <span class="ot">&lt;-</span>environmental</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>(ax <span class="ot">&lt;-</span> <span class="fu">eigen</span>(<span class="fu">cov</span>(dat)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>eigen() decomposition
$values
[1] 8470.53527  996.80291   44.56870    7.61373

$vectors
             [,1]        [,2]         [,3]         [,4]
[1,] -0.143014653  0.96704396  0.202713970  0.057269860
[2,] -0.989119212 -0.14698391  0.004562933 -0.004253672
[3,] -0.033947694  0.19627992 -0.977963641  0.062520905
[4,]  0.006127601 -0.06852667  0.049732711  0.996390087</code></pre>
</div>
</div>
<p>Now, check that the matrix of eigenvectors is orthogonal:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>ax<span class="sc">$</span>vectors <span class="sc">%*%</span> <span class="fu">t</span>(ax<span class="sc">$</span>vectors)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>              [,1]          [,2]         [,3]          [,4]
[1,]  1.000000e+00  3.252607e-19 3.903128e-17 -6.938894e-18
[2,]  3.252607e-19  1.000000e+00 9.492190e-17 -2.341877e-17
[3,]  3.903128e-17  9.492190e-17 1.000000e+00  1.318390e-16
[4,] -6.938894e-18 -2.341877e-17 1.318390e-16  1.000000e+00</code></pre>
</div>
</div>
<p>The diagonals are 1 and the off-diagonals are either 0 or very, very small (order of <span class="math inline">\(10^{-19}\)</span> due to rounding errors.)</p>
<p>Now, check that the sum of eigen-values is same as the sum of variances, i.e., sum of the diagonal elements of the variance-covariance matrix.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(ax<span class="sc">$</span>values)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 9519.521</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(<span class="fu">diag</span>(<span class="fu">cov</span>(dat)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 9519.521</code></pre>
</div>
</div>
</section>
<section id="standardization-centering-and-scaling" class="level3">
<h3 class="anchored" data-anchor-id="standardization-centering-and-scaling">Standardization: centering and scaling</h3>
<p>We are familiar with the idea of standardization. Suppose, we observe univariate data, say, <span class="math inline">\(X_1, X_2, \ldots, X_n\)</span> with a finite mean <span class="math inline">\(\bar{X}\)</span> and variance <span class="math inline">\(s^2\)</span>, i.e., standard deviation <span class="math inline">\(s\)</span>. We can think of standardized values given by: <span class="math display">\[
Z_i = \frac{X_i - \bar{X}}{s}, i =1, \ldots, n.
\]</span> These observatiosn will satisfy: <span class="math inline">\(\bar{Z} = 0\)</span> and <span class="math inline">\(Var(Z) = \frac{1}{n-1}\sum (Z_i - \bar{Z})^2 = 1\)</span>.</p>
<p>Now, recall the formula for sample correlation from observations: <span class="math inline">\(X_1, \ldots, X_n\)</span> and <span class="math inline">\(Y_1, \ldots, Y_n\)</span>.</p>
<p><span class="math display">\[
\begin{align*}
r &amp; = \frac{\frac{1}{n-1}\sum_{i=1}^{n} (X_i - \bar{X})(Y_i - \bar{Y})}{\sqrt{\frac{1}{n-1}\sum_{i=1}^{n} (X_i - \bar{X})^2} \sqrt{\frac{1}{n-1}\sum_{i=1}^{n} (Y_i - \bar{Y})^2}} \\
&amp; = \frac{1}{n-1}\sum_{i=1}^{n} \frac{(X_i - \bar{X})}{s_x} \times \frac{(Y_i - \bar{Y})}{s_Y}.
\end{align*}
\]</span> where, <span class="math inline">\(s_X, s_Y\)</span> are the sample standard deviations of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> samples.</p>
<p>So, another way of calculating correlation is thiking of correlation as the covariance when the <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> variables have been standardized, as shown below:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cor</span>(dat<span class="sc">$</span>ozone, dat<span class="sc">$</span>radiation)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3483417</code></pre>
</div>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cov</span>(<span class="fu">scale</span>(dat<span class="sc">$</span>ozone),<span class="fu">scale</span>(dat<span class="sc">$</span>radiation))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>          [,1]
[1,] 0.3483417</code></pre>
</div>
</div>
</section>
<section id="standardizing-in-more-than-one-dimensions" class="level3">
<h3 class="anchored" data-anchor-id="standardizing-in-more-than-one-dimensions">Standardizing in more than one-dimensions</h3>
<p>In multivariate data, standardization can be done as follows:</p>
<ol type="1">
<li><p>First create the centered matrix <span class="math inline">\(X^c\)</span>, where <span class="math inline">\(X^c_{ij} = x_{ij} - \bar{x}_j\)</span>. So, we can first create the means matrix and subtract from the original <span class="math inline">\(X\)</span> matrix.</p></li>
<li><p>Let <span class="math inline">\(D\)</span> be a <span class="math inline">\(p \times p\)</span> diagonal matrix with the standard deviations on the diagonals, i.e.&nbsp;<span class="math inline">\(d_{ii} = s_i\)</span>.</p></li>
<li><p>Then, the standardized data would be: <span class="math display">\[
Z = X^c D^{-1}
\]</span></p></li>
</ol>
</section>
<section id="standardizing-in-r" class="level3">
<h3 class="anchored" data-anchor-id="standardizing-in-r">Standardizing in <code>R</code></h3>
<p>We can use the <code>scale</code> function, and <code>apply</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>scaled_dat <span class="ot">&lt;-</span> <span class="fu">scale</span>(dat)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">apply</span>(scaled_dat, <span class="dv">2</span>, mean)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        ozone     radiation   temperature          wind 
-1.445896e-17 -1.511847e-16 -2.742465e-16  1.002740e-16 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apply</span>(scaled_dat, <span class="dv">2</span>, sd)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      ozone   radiation temperature        wind 
          1           1           1           1 </code></pre>
</div>
</div>
<p>Why do we care? We’ll see soon, that it’s better to scale the data before applying eigendecomposition to find the principal components.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>